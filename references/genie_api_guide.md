# Genie Conversation API: Quick Start Guide

Ask questions to a Genie space programmatically and retrieve answers, generated SQL, and suggested follow-up questions.

## Overview

The Genie API follows a three-step async pattern:

1. **Start a conversation** — submit a question and receive a `conversation_id` + `message_id`
2. **Poll for completion** — call Get Message repeatedly until `status` reaches a terminal state
3. **Read the response** — extract the SQL query, text summary, and suggested follow-up questions from `attachments`

## Prerequisites

- **Databricks SDK** (`pip install databricks-sdk`)
- **Authentication** configured via one of:
  - Databricks notebook context (auto-authenticates)
  - `~/.databrickscfg` profile (for local development)
  - Environment variables (`DATABRICKS_HOST`, `DATABRICKS_TOKEN`)
- **"Can View" permission** on the target Genie space

## API Endpoints

| Step | Method | Endpoint |
|------|--------|----------|
| Start conversation | `POST` | `/api/2.0/genie/spaces/{space_id}/start-conversation` |
| Get message | `GET` | `/api/2.0/genie/spaces/{space_id}/conversations/{conversation_id}/messages/{message_id}` |

Full API reference: [Genie API (Public Preview)](https://docs.databricks.com/api/workspace/genie)

## Finding Your Space ID

The space ID is the 32-character hex string at the end of the Genie space URL:

```
https://<workspace>.azuredatabricks.net/genie/rooms/<space_id>
                                                     ^^^^^^^^
```

## Complete Example

```python
import json
import time
from databricks.sdk import WorkspaceClient

# --- Configuration ---
SPACE_ID = "your_space_id_here"  # 32-char hex from the Genie space URL
QUESTION = "What are the active Phase 3 oncology trials?"

# --- Setup ---
# In a Databricks notebook, just use: w = WorkspaceClient()
# Locally, configure a profile in ~/.databrickscfg or set env vars
w = WorkspaceClient()

# --- Step 1: Start a conversation ---
waiter = w.genie.start_conversation(space_id=SPACE_ID, content=QUESTION)

conversation_id = waiter.response.conversation_id
message_id = waiter.response.message_id
print(f"Conversation ID: {conversation_id}")
print(f"Message ID:      {message_id}")

# --- Step 2: Poll until the message reaches a terminal status ---
TERMINAL_STATUSES = {"COMPLETED", "FAILED", "CANCELLED", "QUERY_RESULT_EXPIRED"}

while True:
    msg = w.genie.get_message(
        space_id=SPACE_ID,
        conversation_id=conversation_id,
        message_id=message_id,
    )
    status = msg.status.value if msg.status else "UNKNOWN"
    print(f"Status: {status}")

    if status in TERMINAL_STATUSES:
        break
    time.sleep(3)

# --- Step 3: Read the response ---
if msg.status.value == "COMPLETED":
    for att in (msg.attachments or []):

        # SQL query generated by Genie
        if att.query:
            print(f"\n--- Generated SQL ---")
            print(att.query.query)
            print(f"\nDescription: {att.query.description}")
            print(f"Row count:   {att.query.query_result_metadata.row_count}")

        # Natural language summary
        if att.text:
            print(f"\n--- Summary ---")
            print(att.text.content)

        # Suggested follow-up questions
        if att.suggested_questions:
            print(f"\n--- Suggested Follow-up Questions ---")
            for i, q in enumerate(att.suggested_questions.questions or [], 1):
                print(f"  {i}. {q}")
else:
    print(f"Message failed: {msg.error}")
```

## Response Structure

When a message reaches `COMPLETED`, the response contains an `attachments` array with up to three types of attachment:

### 1. Query Attachment

The SQL query Genie generated and executed.

```json
{
  "attachment_id": "...",
  "query": {
    "description": "Human-readable explanation of what the query does",
    "query": "SELECT ... FROM ... WHERE ...",
    "query_result_metadata": {
      "row_count": 100
    },
    "statement_id": "..."
  }
}
```

| Field | Description |
|-------|-------------|
| `query.description` | Plain-English explanation of the generated query |
| `query.query` | The full SQL query string |
| `query.query_result_metadata.row_count` | Number of rows returned |
| `query.statement_id` | Use with the [Statement Execution API](https://docs.databricks.com/api/workspace/statementexecution/getstatement) to fetch full result data |

### 2. Text Attachment

A natural language summary of the results.

```json
{
  "text": {
    "content": "There are 100 active Phase 3 oncology trials..."
  }
}
```

### 3. Suggested Questions Attachment

Follow-up questions generated by Genie based on the current conversation context.

```json
{
  "attachment_id": "...",
  "suggested_questions": {
    "questions": [
      "What are the active Phase 3 trials for specific cancer types such as breast cancer or lung cancer?",
      "How many active Phase 3 oncology trials are there by sponsor?",
      "What is the enrollment count and demographic breakdown for active Phase 3 oncology trials?"
    ]
  }
}
```

| Field | Description |
|-------|-------------|
| `suggested_questions.questions` | Array of follow-up question strings (typically 3) |

## Message Status Lifecycle

```
SUBMITTED → FETCHING_METADATA → FILTERING_CONTEXT → ASKING_AI → PENDING_WAREHOUSE → EXECUTING_QUERY → COMPLETED
```

| Status | Description |
|--------|-------------|
| `SUBMITTED` | Message received |
| `FETCHING_METADATA` | Loading table/column metadata |
| `FILTERING_CONTEXT` | Selecting relevant context |
| `ASKING_AI` | Waiting for LLM to generate SQL |
| `PENDING_WAREHOUSE` | Waiting for SQL warehouse |
| `EXECUTING_QUERY` | Running the generated SQL |
| `COMPLETED` | Done -- results are in `attachments` |
| `FAILED` | Error occurred -- check `error` field |

## Multi-turn Conversations

To ask a follow-up question in the same conversation (maintaining context), use the Create Message endpoint:

```python
# Send a follow-up in the same conversation
follow_up = w.genie.create_message(
    space_id=SPACE_ID,
    conversation_id=conversation_id,  # reuse from step 1
    content="How many of those are sponsored by Merck?",
)

# Poll the new message the same way
follow_up_msg_id = follow_up.response.message_id
# ... poll with get_message using the same conversation_id and the new message_id
```

